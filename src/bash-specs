#!/usr/bin/env bash

# Copyright (C) 2012 Oliver Weiler
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

shopt -s nullglob

LC_NUMERIC='C'
TIMEFORMAT='%R'

readonly version_number='1.0.0'

read -d '' version <<- EOF
	bash-specs $version_number
EOF

readonly red=$(tput setaf 1)
readonly green=$(tput setaf 2)
readonly cyan=$(tput setaf 6)
readonly default_color=$(tput setaf 9)

number_of_specs='0'
number_of_specs_failed='0'

total_elapsed_time='0'

error_message=''

main() {
	(($# == 0)) && set -- *.suite

	printf '%s\n' "$version"

        trap '__cleanup_exit' EXIT

	for suite; do
		. "$suite"
	done

	__print_summary
}

describe() {
	printf '\n%s%s\n' "$default_color" "$1"
}

before_each() {
        :
}

expect() {
        $2 $1 ${@:3}
}

to_equal() {
        (($1 == $2)) && return 0

        __build_error_message "$1" "$FUNCNAME" "$2"

        return 1
}

to_be_less_than() {
        (($1 < $2)) && return 0

        __build_error_message "$1" "$FUNCNAME" "$2"

        return 1
}

to_be_greater_than() {
	(($1 > $2)) && return 0

        __build_error_message "$1" "$FUNCNAME" "$2"

	return 1
}

to_contain() {
        if is_array $1; then
                for e in $1; do
                  [[ $e == $2 ]] && return 0
                done

                __build_error_message "$1" "$FUNCNAME" "$2"

                return 1
        fi 

        [[ $1 == *$2* ]] && return 0

        __build_error_message "$1" "$FUNCNAME" "$2"
}

to_match() {
	if ! [[ $1 =~ $2 ]]; then
                __build_error_message "$1" "$FUNCNAME" "$2"

		return 1
	fi
}

__build_error_message() {
        error_message="Expected '$1' ${2//_/ } '$3'."
}

__is_array() {
        [[ $(declare -p $1) == "declare -a"* ]]
}

it() {
	before_each

	__execute_spec "$@"

	after_each
}

__execute_spec() {
        local elapsed_time=$({ time "$2" > /dev/null 2>&1; } 2>&1)
	local result=$?

        ((number_of_specs++))

	__accumulate_total_elapsed_time "$elapsed_time"

	if ((result == 0)); then
		__print_spec_result "$green" "$1" "$elapsed_time"

		return
	fi

	((number_of_specs_failed++))
	__print_spec_result "$red" "$1" "$elapsed_time"

	if [[ -n $error_message ]]; then
		printf '    %s\n' "$error_message"
		error_message=''
	fi
}

__accumulate_total_elapsed_time() {
	((total_elapsed_time += 10#${1/./}))
}

__print_spec_result() {
	printf '%s  %s%s (%.3f s)\n' "$1" "$2" "$cyan" "$3"
}

xit() {
  :
}

after_each() {
	:
}

__cleanup_exit() {
        tput sgr0
}

__print_summary() {
	local units
	((number_of_specs == 1)) && units='spec' || units='specs'
	local color
	((number_of_specs_failed == 0)) && color=$green || color=$red
	local secs=$((total_elapsed_time / 1000))
	local millisecs=$((total_elapsed_time % 1000))

	printf '\n%s%s %s, %s failed%s (%d.%03d s)%s\n' "$color" "$number_of_specs" "$units" "$number_of_specs_failed" "$cyan" "$secs" "$millisecs" "$default_color"
}

main "$@"
